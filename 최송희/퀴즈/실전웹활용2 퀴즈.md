[질문]
지연로딩과 조회성능 최적화를 할 수 있는 방법 중에 DTO로 바로 리포지토리를 조회하는 방법이 있었다. 이 방법의 특징에 대해 설명하고 쿼리방식 선택에 있어서 권장하는 순서는 무엇인지? 

[답변]
엔티티로 조회하는 것보다, DTO로 리포지토리를 조회하는 경우 다음과 같은 특징이 있다.
- 일반적인 SQL을 사용하는 것처럼 원하는 값을 선택해서 조회할 수 있고
- new 명령어를 사용해서 JPQL결과를 즉시 DTO로 변환
- SELECT절에서 원하는 데이터를 직접 선택하기 때문에 DB에서 어플리케이션으로의 네트워크 용량이 최적화된다.(미비)
- 하지만, 리포지토리 재사용성이 떨어지며 API스펙에 맞춘 코드가 리포지토리에 작성되는 단점이 있다.

### 쿼리방식 선택 권장 순서
1. 우선 엔티티를 DTO로 변환하는 방법을 선택
2. 필요하면 페치조인으로 성능 최적화
3. 그래도 안되면 DTO로 직접 조회
4. 최후 방법으로, 네이티브 SQL이나 스프링 JDBC Template을 사용해 SQL 직접 사용

<br/>
<br/>

[질문]
컬렉션 조회 최적화에서 지연로딩으로 인해 쿼리 하나를 실행하면 지연로딩된 엔티티들이 N번씩 실행하게 된다. 따라서 이를 페치조인하면 SQL이 한번만 실행하게 되는데, 여기서 사용하는 distinct의 역할은 무엇인가?

[답변]
JPA의 distinct는 SQL에도 distinct를 추가하고, 같은 엔티티가 조회되면 추가적으로 애플리케이션에서 중복을 걸러주는 역할을 한다. 따라서, 컬렉션 페치조인 때문에 중복조회 되는 것을 막아준다. 


<br/>
<br/>

[질문]
컬렉션 페치조인은 컬렉션 조회 최적화 방법 중 하나에 속한다. 이 방법은 단점이 있다면 무엇이고, 그 문제가 발생하는 이유는 무엇일까?

[답변]
컬렉션 페치조인은 SQL을 한번만 실행하게 하지만, 페이징이 불가능해진다. 모든 데이터를 DB에서 읽어오고 메모리에서 페이징해버린다.(**매우 위험**)

<br/>
<br/>

[질문]
페이징도 하고 컬렉션 엔티티를 조회하는 방법을 설명하면?

[답변]
1. ToOne관계를 모두 페치조인한다. 
ToOne관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다. 
2. 컬렉션은 지연로딩으로 조회한다. 다만, 지연로딩 성능 최적화를 위해 (전역설정)`hibernate.default_batch_fetch_size`, (개별설정)`@BatchSize`를 적용한다.
이 설정을 통해 프록시 객체, 컬렉션을 설정한 size만큼 IN쿼리로 조회한다.