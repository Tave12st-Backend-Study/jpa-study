## 연관관계 매핑시 고려사항 3가지
1. 다중성
2. 단방향, 양방향
3. 연관관계의 주인


### 다중성
- 다대일, 일대다, 일대일, 다대다가 있다. 

### 단방향, 양방향
- [테이블] 외래키 하나로 양쪽 조인이 가능하며 두 테이블이 연관관계를 맺는다. 테이블에서는 방향이라는 개념이 없다.
- [객체] 참조용 필드가 있는 쪽으로만 참조가능, 한쪽만 참조하면 단방향, 서로 참조하면 양방향이다. 양방향관계는 참조가 2군데로, 외래키를 관리할 곳을 지정해주어야 한다.
- 연관관계의 주인은 외래키를 관리할 수 있으며, 주인이 아닌 쪽은 조회만 가능하다.

### 1. 다대일 단방향
**N쪽 : 외래키가 있는 쪽으로 = 연관관계의 주인이다.**

[테이블] : 항상 N쪽에 외래키가 존재하도록 설계
[객체] : N쪽에 참조할 객체 필드 선언(테이블과 연관관계 매핑)

예시) N(Member) : 1(Team)

```java
Member class...

@Id @GeneratedValue //생략하면 AUTO
@Column(name = "MEMBER_ID")
private Long id;
private String username;

@ManyToOne
@JoinColumn(name = "TEAM_ID")
private Team team;
```

```java
Team class...

@Id
@GeneratedValue
@Column(name = "TEAM_ID")
private Long id;
private String name;
```

### 2. 다대일 양방향
1번 다대일 단방향 코드 중 객체 Team에 List<Member>만 추가해주면 된다.

예시) N(Member) : 1(Team)

```java
Member class...

@Id @GeneratedValue //생략하면 AUTO
@Column(name = "MEMBER_ID")
private Long id;
private String username;

@ManyToOne
@JoinColumn(name = "TEAM_ID")
private Team team;
```

```java
Team class...

@Id
@GeneratedValue
@Column(name = "TEAM_ID")
private Long id;
private String name;
@OneToMany(mappedBy = "team")
private List<Member> members = new ArrayList<>();
```


### 3. 일대다 단방향(권장X)
1쪽 : 연관관계의 주인이 되겠다.
N쪽 : 외래키를 가진다.

- JOIN COLUMN을 꼭 1쪽에 작성해주어야 한다.

예시) N(Member) : 1(Team) .. **1쪽에서 연관관계의 주인으로 설정**된다. 

```java
Member class...

@Id @GeneratedValue //생략하면 AUTO
@Column(name = "MEMBER_ID")
private Long id;
private String username;

```

```java
Team class...

@Id
@GeneratedValue
@Column(name = "TEAM_ID")
private Long id;
private String name;

@OneToMany
@JoinColumn(name = "TEAM_ID")
private List<Member> members = new ArrayList<>();
```

객체의 TEAM(1쪽)과 테이블의 MEMBER의 TEAM_ID와 연관관계 매핑이 된다.
반대편 테이블(MEMBER)의 외래키를 관리하는 특이한 구조가 된다.

-> 일대다 대신, 필요할 경우 다대일 단방향을 **다대일 양방향으로 바꾸어서 사용하도록 한다.**



### 4. 일대다 양방향(권장X)

- 공식적으로 이러한 매핑은 존재x

- `@JoinColumn(insertable = false, updatable = false)` : MEMBER(N쪽)에 매핑이 되는 컬럼에 작성해준다. TEAM과 MEMBER에 모두 @JoinColumn을 작성해주면 모두 연관관계 주인이 되지만, MEMBER에는 `insertable = false, updatable = false`를 추가해주면 읽기전용이 된다.

예시) N(Member) : 1(Team) .. **1쪽에서 연관관계의 주인으로 설정**된다. 

```java
Member class...

@Id @GeneratedValue //생략하면 AUTO
@Column(name = "MEMBER_ID")
private Long id;
private String username;

@ManyToOne
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false) //읽기전용
private Team team;

```

```java
Team class...

@Id
@GeneratedValue
@Column(name = "TEAM_ID")
private Long id;
private String name;

@OneToMany
@JoinColumn(name = "TEAM_ID")
private List<Member> members = new ArrayList<>();
```


-> 결론 : **다대일 양방향을 사용**



### 5. 일대일 관계

- 주 테이블이나 대상 테이블 중 외래키 선택이 가능
(주 테이블에 외래키를 넣거나 or 대상 테이블에 외래키를 넣는 방법이 있다.)

- 외래키에 데이터베이스 유니크 제약조건을 추가되어야 일대일 관계가 된다.

- 단방향, 양방향인 경우는 다대일 관계와 유사하게 작성하면 된다.

- **연관관계의 주인이 되는 쪽 : 외래키가 있는 곳**

[단방향]

예시) 1(Member) : 1(Locker) .. **외래키가 있는 곳을 연관관계의 주인으로 설정**된다. 

```java
Member class...

@Id @GeneratedValue //생략하면 AUTO
@Column(name = "MEMBER_ID")
private Long id;
private String username;

@ManyToOne
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false) //읽기전용
private Team team;

@OneToOne
@JoinColumn(name = "LOCKER_ID")
private Locker locker;
```

```java
Locker class...

@Id @GeneratedValue
@Column(name = "LOCKER_ID")
private Long id;
private String name;
```



[양방향]


```java
Member class...

@Id @GeneratedValue //생략하면 AUTO
@Column(name = "MEMBER_ID")
private Long id;
private String username;

@ManyToOne
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false) //읽기전용
private Team team;

@OneToOne
@JoinColumn(name = "LOCKER_ID")
private Locker locker;
```

```java
Locker class...

@Id @GeneratedValue
@Column(name = "LOCKER_ID")
private Long id;
private String name;

@OneToOne(mappedBy = "locker")
private Member member;
```