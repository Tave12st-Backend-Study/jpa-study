## 엔티티 클래스 개발

- 외래키가 있는 곳을 연관관계의 주인으로 정한다. <br>
연관관계의 주인은 단순히 외래키를 누가 관리하냐의 문제일 뿐이다. 
- 실무에서는 조회할 일이 많으므로 Getter를 모두 열어두는 것이 편리하다. 
Getter는 아무리 호출해도 호출하는 것만으로 어떠한 일이 발생하지 않기 때문이다. 하지만, Setter은 호출할 경우 데이터가 변한다. 이렇게 Setter를 무작위적으로 사용하게 될 경우에는 엔티티가 어디에서 왜 변경되었는지 점점 추적하기 어려워진다. 따라서 엔티티를 변경할 때 Setter 대신 변경지점이 명확하도록 메서드를 별도로 제공해야 한다.

- 참고로 실무에서는 @ManyToMany를 사용하지 않도록 한다.
중간 테이블에 컬럼을 추가할 수도 없고, 세밀하게 쿼리를 실행하기 어렵기 때문에 사용하기엔 한계가 많다. 따라서 다대다 매핑은 일대다, 다대일 매핑으로 풀어서 사용한다.

- `임베디드 타입`은 public 혹은 protected로 설정해서 사용하도록 한다. public으로 두는 것보다는 protected로 사용하는 것이 그나마 안전하게 생성자를 사용하지 않도록 할 수 있다. 
이때 임베디드 타입으로 선언할 클래스에는 @Embeddable을, 임베디드 타입을 사용할 클래스에는 @Embedded를 사용해 임베디드 타입을 활용하도록 한다.

- 엔티티 설계시 주의할 점은 3가지다.
1. 엔티티에는 가급적 Setter를 사용하지 않도록 한다.
변경 포인트가 너무 많아서 유지보수가 어렵다. 나중에 리펙토링으로 setter를 제거하도록 한다.

<br/>

2. 모든 연관관계는 지연로딩으로 설정한다.
즉시로딩은 예측이 어렵고 SQL이 어떻게 실행될지 추적이 어렵기 때문이다. 특히 JPQL를 실행할 때 n+1문제가 자주 발생한다.
- 모든 연관관계는 지연로딩으로 설정해 사용한다.
- @XToOne 관계는 모두 기본 default값이 즉시로딩이므로 직접 지연로딩으로 설정해야만 한다.(fetch = FetchType.LAZY)

<BR/>

3. 컬렉션은 필드에서 초기화해서 사용하도록 한다.
NULL 문제에서 안전하게 유지할 수 있다. 하이버네이트는 엔티티를 영속화할 때, 컬렉션을 감싸 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 만약 잘못 컬렉션을 생성하면 내부 메커니즘에 문제가 발생하므로 필드레벨에서 초기화해서 사용하는 것이 가장 안전하고 코드도 간결하다.

<BR/>

- 테이블, 컬럼명 생성전략
엔티티(필드) 를 테이블(칼럼)으로 바꿀 때 전략은 다음과 같다.<BR/>
1. 카멜 케이스는 언더스코어로 바뀐다.(memberPoint -> member_point)
2. . 은 언더스코어로 바뀐다.
3. 대문자는 소문자로 바뀐다.


<br/>
<br/>

## 리포지토리 클래스 개발

- 기술 설명
@Repository : 스프링 빈으로 등록하며, jpa 예외를 스프링 기반 예외로 예외를 변환하는 역할을 한다<br/>
@PersistenceContext : 엔티티 매니저를 주입하는 역할을 한다.<br/>
@PersistenceUnit : 엔티티 매니저 팩토리를 주입하는 역할을 한다.<br/>
@Transactional : 트랜잭션, 영속성 컨텍스트와 관련된 어노테이션으로, `readOnly = true`를 추가하는 경우는 데이터의 변경이 없는 읽기 전용 메서드에서 사용한다. 영속성 컨텍스트를 플러시 하지 않으므로 성능향상에 도움이 된다.
