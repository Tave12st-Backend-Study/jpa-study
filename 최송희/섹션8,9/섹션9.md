## 목차
1. 기본값 타입
2. **임베디드 타입(복합 값 타입)**
3. 값 타입과 불변 객체
4. 값 타입의 비교
5. **값 타입 컬렉션**
6. 실전 예제 - 6. 값 타입 매핑



<BR/>
<BR/>

### 1. 기본값 타입
크게 엔티티타입과 값 타입으로 나뉜다.
1) 엔티티 타입
- @Entity로 정의하는 객체
- 데이터가 변해도 식별자로 지속해서 추적 가능
- 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
<br/>
2) 값 타입
- int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
- 식별자가 없고 값만 있으므로 변경시 추적 불가
- 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

<br/>
<br/>

#### [값 타입의 분류]
1) 기본값 타입
- 자바 기본 타입(int, double) <-항상 값을 복사해서 사용됨
- 래퍼 클래스(Integer, Long) <- 공유는 가능하나, 변경되지 않음
- String 클래스
<br/>
<br/>
기본값 타입은 엔티티의 생명주기에 의존한다. 
ex. 회원 삭제 ... 나이필드도 함께 삭제된다.
[참고]<br/>
자바의 기본 타입은 절대 공유되지 않는다..(개발할때 충돌이 나지 않는 이유 중 하나에 속함)<br/>



2) **임베디드 타입**
3) **컬렉션 값 타입**


<BR/>
<BR/>

### 2. 임베디드 타입
- 새로운 값 타입을 직접 정의할 수 있다.
- 주로 기본값 타입을 모아서 만들어서 복합 값 타입이라고도 한다.
<br/>
ex. 회원 엔티티는 이름, 근무기간, 집 주소를 가진다.<BR/>

- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded : 값 타입을 사용하는 곳에 표시
- **기본 생성자 필수!**
- 의미있는 메소드를 만들 수 있다.
- 임베디드 타입(값 타입에 포함되는 타입)을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함
<br/>
<br/>

#### [임베디드 타입과 테이블 매핑]
- 임베디드 타입은 엔티티의 값일 뿐이다. 
- 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다. 
- 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가
능
- 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래
스의 수가 더 많음
<br/>
<br/>

#### [임베디드 타입과 연관관계]
- 임베디드로 설정한 클래스 안에 엔티티를 작성할 수도 있다.

<br/>
<br/>

#### [임베디드 타입]

- 한 엔티티에서 같은 값 타입을 사용한다면...@Embedded가 여러개 작성된다.
<br/>

예로 들면
```java
package jpabook;

import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;

@Entity
public class Member{
    @Id
    @GeneratedValue //생략하면 AUTO
    @Column(name = "MEMBER_ID")
    private Long id;
    private String username;

    @Embedded
    //기간
    private Period workPeriod;

    //주소
    @Embedded
   private Address homeAddress;

    @Embedded
    private Address workAddress;
}

```

<br/>
이렇게 작성하면 에러가 난다. <br/>

[문제 원인] 컬럼 명이 중복되기 때문에 나타나는 문제

[사용법] `@AttributeOverrides, 하나면 @AttributeOverride`를 사용해서
컬러 명 속성을 재정의하면 된다.
