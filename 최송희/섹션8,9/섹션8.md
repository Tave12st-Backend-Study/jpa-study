## 목차
1. 프록시
2. 즉시로딩과 지연로딩
3. 지연로딩 활용
4. 영속성 전이 :CASCADE
5. 고아 객체
6. 실전예제


<BR/>
<BR/>

### 1. 프록시

<br/>

#### [프록시 기초]

em.find() vs em.getReference()를 비교해보면,<br/>
em.find() : 데이터베이스를 통해 실제 엔티티 객체를 조회, sql 쿼리문이 나간다.<br/>
em.getReference() : 엔티티 객체의 필드를 조회하려고 할 때 그 때 데이터베이스에 대한 sql쿼리문이 실행, 데이터베이스 조회를 미룬다.


```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
EntityManager em = emf.createEntityManager();

EntityTransaction tx = em.getTransaction();
tx.begin();
try{
    Member member = new Member();
    member.setUserName("hello");

    em.persist(member);

    em.flush();
    em.clear();

// Member findMember = em.find(Member.class, member.getId());
// System.out.println("findMember.id = "+findMember.getId());

    Member findMember2 = em.getReference(Member.class, member.getId());//1
    System.out.println("findMember = "+ findMember2.getClass()); //0
    System.out.println("findMember.id = "+findMember2.getId());//2
    System.out.println("findMember.id = "+findMember2.getUserName()); //3

    tx.commit();
}catch(Exception e){
    tx.rollback();
}finally {
    em.close();
}
emf.close();
```

1, 2번 -- SELECT 쿼리문이 실행x<br/>
3번 -- SELECT 쿼리문이 실행o<Br/>
<br/>
0번 -- `findMember = class jpabook.Member$HibernateProxy$z10qFr6p` 로 출력된다.<br/>
= 프록시가 붙은 객체임을 알 수 있다.


<br/>
<br/>

#### [프록시 특징]

em.getReference() 
:<br/>
- 실제 엔티티를 상속받아서 겉모양이 같게 만들어진다.
- 실제 객체의 참조를 보관한다.
Proxy<br/>
[Entity target(실제 객체에 대한 참조)]<br/>
[getId()]<br/>
:<br/>
프록시 객체에 없는 값을 요청한다면 아래와 같은 로직이 작동<br/>
1. Client가 프록시.getName() 요청
2. 프록시에는 getName()이 없으면 영속성 컨텍스트에 초기화 요청
3. 영속성 컨텍스트 -> DB 조회
4. 영속성 컨텍스트 -> 실제 Entity 생성(프록시 객체가 실제 엔티티로 바뀌는 것이 아니다.)
5. target.getName() 가지고 옴
<br/>
:<br/>
- 프록시 객체 초기화할 때, **프록시 객체가 실제 엔티티로 바뀌는 것이 아니다.**
- 프록시 객체는 원본 엔티티를 상속받음
- **타입체크시 `instance of` 사용**(== 체크X)
- **영속성 컨텍스트에 객체가 채워진 후 -> `em.getReference`하는 경우, 영속성 컨텍스트 실제 엔티티객체를 상속받음**(이 경우 프록시 객체가 X)(반대도 성립!)<br/>

```java
Member m1 = em.find(Member.class, member1.getId());    
Member m1Reference = em.getReference(Member.class, member1.getId());

System.out.println("reference = :"+m1Reference.getClass());
System.out.println("m1 == m1Reference: "+(m1 == m1Reference));
```
<br/>

[출력결과] <br/>
reference = :class jpabook.Member<br/>
m1 == m1Reference: true<Br/>
(== 비교에도 true로 출력됨)<br/>


=> **JPA는 한 트랜잭션 안에서 같은 영속성 컨텍스트에서 가져온 객체로 == 비교를 한다면 true로 보장**<br/>

- **`em.getReference`로 프록시 객체를 반환 받은 후 -> `em.find`하는 경우에도 같은 프록시 객체를 반환받게 된다.**

