## 목차
1. JPQL
2. JPA Criteria
3. QueryDSL
4. 네이티브 SQL

<BR/>
<BR/>
<BR/>

### 1. JPQL

- 가장 단순한 조회 방법
- JPA를 사용하면 **엔티티 객체**를 중심으로 개발
- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, 
HAVING, JOIN 지원
- JPQL을 한마디로 정의하면 객체 지향 SQL
- [단점] 동적 쿼리 만들기 어려움

```java
List<Member> result  = em.createQuery(
        "select m From Member m where m.username like '%kim%",
                Member.class)
        .getResultList();
//member 엔티티 자체를 조회해오라는 의미
//단점 :  동적쿼리를 만들기 어렵다.
//String sqlString = "select m From Member m" + String where = "where m.username like '%kim%' 이렇게 하기 어려움

```

<br/>
<br/>
<br/>

### 2. Criteria

- 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
- JPQL 빌더 역할
- 컴파일 시점에 문법 오류를 찾을 수 있음
- Criteria 대신에 QueryDSL 사용 권장
- [단점] 너무 복잡하고 실용성이 없다.

```java
//2.Criteria(망한 스펙, 실무에서 사용하지 않는 스펙)
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);
//Member에서
Root<Member> m = query.from(Member.class);
//m을 select, m의 username이 kim인 것을 추출
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));

List<Member> resultList = em.createQuery(cq).getResultList();

//장점 : 동적쿼리가 가능/sql 작성을 올바르게 작성해주도록 컴파일시점에 오타를 잡아준다.
//단점 : sql 스럽지 않다. 실무에서는 안쓴다. 유지보수가 어렵다.
```

<br/>
<br/>
<br/>

### 3. QueryDSL(실무 사용 권장)

- 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
- JPQL 빌더 역할
- 컴파일 시점에 문법 오류를 찾을 수 있음
- [장점] 동적쿼리 작성 편리함/단순하고 쉬움

<br/>
<br/>
<br/>

### 4. 네이티브 SQL

- JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 사용할 때 사용된다. <br/>예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트

```java
//4. 네이티브 SQL(잘 안씀)
em.createNativeQuery(
        "select MEMBER_ID, city, street. zipcode, USERNAME from MEMBER"
).getResultList();
```

<br/>
<br/>
<br/>

### 5. JDBC 직접 사용, SpringJdbcTemplate 등

- JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능
- 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요<br/>
예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트
수동 플러시

<br/>

```java
//5. JDBC
//조심해야할 점 : 영속성 컨텍스트는 플러시가 되어야 db에 데이터가 있다.

//(AUTO전략)flush되는 시점 : commit되기 전, query날아가기 전에 동작
// => flush되면 DB에 적용된다.

//예
Member member =  new Member();
member.setUsername("member1");
em.persist(member);

//이 시점에 em.flush()가 자동으로 날아가 DB에 insert해준다.

//1번의 경우
List<Member> resultList1 = em.createNativeQuery(
        "select MEMBER_ID, city, street, zipcode FROM MEMBER"
).getResultList();

// 반면 JDBC는 jpa가 아니므로 다음과 같이 작성해준다면
//em.flush() x -> DB에 값이 없다. , 오류 발생
//수동으로 em.flush() 작서해야 한다.

//2번의 경우
//dbconn.executeQuery("select * from member");

```

<br/>
<br/>
<br/>

### 1. JPQL 소개

- JPQL은 객체지향 쿼리 언어다.따라서 테이블을 대상으로 쿼리를 날리는 것이 아니라 `엔티티 객체를 대상`으로 쿼리한다

- JPQL은 결국 SQL로 변환된다
- 엔티티와 속성은 대소문자 구분O (Member, age)
- JPQL 키워드는 대소문자 구분X (SELECT, FROM, where)
- 엔티티 이름 사용, 테이블 이름이 아님(Member)
- 별칭은 필수(m) (as는 생략가능)
<br/>

예) select m from Member as m where m.age > 18

<br/>
<br/>
<br/>

#### 1) [TypeQuery, Query]
- TypeQuery: 반환 타입이 명확할 때 사용
- Query: 반환 타입이 명확하지 않을 때 사용

```java
Member member =  new Member();
member.setUsername("member1");
em.persist(member);

//반환 타입이 명확할때 사용 :: TypedQuery<제네릭>
TypedQuery<Member> query = em.createQuery("" +
        "SELECT m FROM Member m", Member.class);
TypedQuery<String> query1 = em.createQuery(
        "SELECT m.username FROM Member m", String.class
);

//반환타입이 명확하지 않을 때 사용 :: Query
Query query2 = em.createQuery(
        "SELECT m.username, m.age FROM Member m"
);
```

<br/>
<br/>
<br/>

#### 2) [결과조회 API]

- 1) query.getResultList(): 결과가 하나 이상일 때, 리스트 반환
   - 결과가 없으면 빈 리스트 반환
- 2) query.getSingleResult(): 결과가 정확히 하나, 단일 객체 반환
   - 결과가 없으면: javax.persistence.NoResultException
   - 둘 이상이면: javax.persistence.NonUniqueResultException



#### 3) [파라미터 바인딩]

```java
 Member member =  new Member();
member.setUsername("member1");
em.persist(member);

//반환 타입이 명확할때 사용 :: TypedQuery<제네릭>
TypedQuery<Member> query = em.createQuery(
        "SELECT m FROM Member m WHERE m.username = :username", Member.class);
//파라미터 바인딩- 이름기준일때
query.setParameter("username", "member1");
Member singleResult = query.getSingleResult();
System.out.println("singleResult = "+singleResult);

//파라미터 바인딩-위치기준(추천 X)

tx.commit();
```